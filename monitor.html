<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>Santa 2025 JS Validator - Relaxed Overlap</title><style>body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #121212; color: #e0e0e0; margin: 20px; }
.header { display: flex; gap: 20px; align-items: center; background: #1e1e1e; padding: 20px; border-radius: 10px; border: 1px solid #333; }
.metric-card { background: #252525; padding: 15px; border-radius: 8px; min-width: 150px; border-bottom: 4px solid #ff4b4b; }
.metric-val { font-size: 1.5rem; font-weight: bold; color: #fff; }
.controls { margin: 20px 0; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
.controls > div { display: flex; align-items: center; gap: 5px; }
.controls input[type="file"], .controls input[type="number"] { height: 32px; padding: 4px 8px; }
.controls button { height: 32px; padding: 8px 16px; }
table { width: 100%; border-collapse: collapse; margin-top: 20px; background: #1e1e1e; }
th, td { padding: 12px; text-align: left; border-bottom: 1px solid #333; }
tr.fail { background: #451a1a; }
tr.win { background: #1a3d25; }
.status-ok { color: #4ade80; }
.status-fail { color: #f87171; font-weight: bold; }
canvas { background: #000; border: 1px solid #444; margin-top: 10px; display: block; }
.tolerance-control { display: flex; align-items: center; gap: 5px; }
</style></head><body><div class="header"><div class="metric-card"><div>Current Score</div><div id="cur-score" class="metric-val">0.00000000</div></div><div class="metric-card" style="border-color: #4a90e2;"><div>Clean Score</div><div id="cln-score" class="metric-val">0.00000000</div></div><div class="metric-card" style="border-color: #4ade80;"><div>Improvement</div><div id="delta-score" class="metric-val">0.00000000</div></div></div><div class="controls"><div><label>Submission.csv:</label><input type="file" id="file-sub" accept=".csv"></div><div><label>Submission_clean.csv:</label><input type="file" id="file-cln" accept=".csv"></div><div class="tolerance-control"><label>Overlap Tolerance:</label><input type="number" id="tolerance" value="0.0001" step="0.001" min="0" max="0.1" style="width: 80px;"></div><button onclick="runComparison()" style="cursor:pointer;">Analyze Files</button></div><div id="results-area"><table id="results-table"><thead><tr><th>N Group</th><th>Overlap Status</th><th>Box max side</th><th>Current Score</th><th>Diff vs Clean</th><th>Visual (Preview)</th></tr></thead><tbody></tbody></table></div><script>const TREE_COORDS = [[0.0, 0.8], [0.125, 0.5], [0.0625, 0.5], [0.2, 0.25], [0.1, 0.25], [0.35, 0.0], [0.075, 0.0], [0.075, -0.2], [-0.075, -0.2], [-0.075, 0.0], [-0.35, 0.0], [-0.1, 0.25], [-0.2, 0.25], [-0.0625, 0.5], [-0.125, 0.5]];
function parseCSV(text) { const lines = text.split('\n').filter(l => l.trim().length > 0); const data = {}; for (let i = 1; i < lines.length; i++) { const parts = lines[i].split(',').map(s => s.replace(/"/g, '').replace('s', '').trim()); if (parts.length < 4) continue; const [id, x, y, deg] = parts; const group = id.split('_')[0]; if (!data[group]) data[group] = []; data[group].push({ x: parseFloat(x), y: parseFloat(y), deg: parseFloat(deg) }); } return data; }
function getPolygons(trees) { return trees.map(t => { const rad = t.deg * Math.PI / 180; const cos = Math.cos(rad); const sin = Math.sin(rad); const pts = TREE_COORDS.map(p => ({ x: (p[0] * cos - p[1] * sin) + t.x, y: (p[0] * sin + p[1] * cos) + t.y })); let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity; pts.forEach(p => { minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x); minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y); }); return { pts, minX, maxX, minY, maxY }; }); }
function intersects(polyA, polyB, tolerance = 0) {
 const margin = tolerance;
 if (polyA.maxX + margin < polyB.minX - margin || polyB.maxX + margin < polyA.minX - margin || polyA.maxY + margin < polyB.minY - margin || polyB.maxY + margin < polyA.minY - margin) return false;
 const crossProduct = (a, b, c) => (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
 const segmentsIntersect = (p1, p2, p3, p4) => {
 const d1 = crossProduct(p3, p4, p1);
 const d2 = crossProduct(p3, p4, p2);
 const d3 = crossProduct(p1, p2, p3);
 const d4 = crossProduct(p1, p2, p4);
 const eps = tolerance * 10;
 if (((d1 > eps && d2 < -eps) || (d1 < -eps && d2 > eps)) && ((d3 > eps && d4 < -eps) || (d3 < -eps && d4 > eps))) return true;
 return false;
 };
 for (let i = 0; i < polyA.pts.length; i++) {
 let a1 = polyA.pts[i], a2 = polyA.pts[(i + 1) % polyA.pts.length];
 for (let j = 0; j < polyB.pts.length; j++) {
 let b1 = polyB.pts[j], b2 = polyB.pts[(j + 1) % polyB.pts.length];
 if (segmentsIntersect(a1, a2, b1, b2)) return true;
 }
 }
 return false;
}
async function runComparison() { const fileSub = document.getElementById('file-sub').files[0]; const fileCln = document.getElementById('file-cln').files[0]; if (!fileSub || !fileCln) return alert('Please select both files.'); const tolerance = parseFloat(document.getElementById('tolerance').value); const subText = await fileSub.text(); const clnText = await fileCln.text(); const subData = parseCSV(subText); const clnData = parseCSV(clnText); const tbody = document.querySelector('#results-table tbody'); tbody.innerHTML = ''; let totalSubScore = 0; let totalClnScore = 0; const groups = Object.keys(subData).sort((a,b) => parseInt(b)-parseInt(a)); groups.forEach(g => { const subTrees = subData[g]; const clnTrees = clnData[g] || []; const subPolys = getPolygons(subTrees); const clnPolys = getPolygons(clnTrees); let hasOverlap = false; let overlapPairs = []; for (let i = 0; i < subPolys.length; i++) { for (let j = i + 1; j < subPolys.length; j++) { if (intersects(subPolys[i], subPolys[j], tolerance)) { hasOverlap = true; overlapPairs.push([i, j]); } } } let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity; subPolys.forEach(p => { minX = Math.min(minX, p.minX); maxX = Math.max(maxX, p.maxX); minY = Math.min(minY, p.minY); maxY = Math.max(maxY, p.maxY); }); const subSide = Math.max(maxX - minX, maxY - minY); const subScore = (subSide * subSide) / subTrees.length; totalSubScore += subScore; let cminX = Infinity, cmaxX = -Infinity, cminY = Infinity, cmaxY = -Infinity; clnPolys.forEach(p => { cminX = Math.min(cminX, p.minX); cmaxX = Math.max(cmaxX, p.maxX); cminY = Math.min(cminY, p.minY); cmaxY = Math.max(cmaxY, p.maxY); }); const clnSide = Math.max(cmaxX - cminX, cmaxY - cminY); const clnScore = clnTrees.length ? (clnSide * clnSide) / clnTrees.length : subScore; totalClnScore += clnScore; const diff = subScore - clnScore; const row = document.createElement('tr'); if (hasOverlap) row.className = 'fail'; else if (diff < -1e-9) row.className = 'win'; row.innerHTML = `<td>${g}</td><td class="${hasOverlap ? 'status-fail' : 'status-ok'}">${hasOverlap ? '❌ OVERLAP' : '✅ LEGAL'}</td><td>${subSide.toFixed(20)}</td><td>${subScore.toFixed(20)}</td><td>${diff.toFixed(20)}</td><td><canvas id="cv-${g}" width="100" height="100"></canvas></td>`; tbody.appendChild(row); drawPreview(`cv-${g}`, subPolys, minX, maxX, minY, maxY, overlapPairs); }); document.getElementById('cur-score').innerText = totalSubScore.toFixed(20); document.getElementById('cln-score').innerText = totalClnScore.toFixed(20); document.getElementById('delta-score').innerText = (totalSubScore - totalClnScore).toFixed(20); }
function drawPreview(id, polys, minX, maxX, minY, maxY, overlapPairs) { const canvas = document.getElementById(id); const ctx = canvas.getContext('2d'); const size = Math.max(maxX - minX, maxY - minY); const scale = 90 / size; const overlapIndices = new Set(); overlapPairs.forEach(pair => { overlapIndices.add(pair[0]); overlapIndices.add(pair[1]); }); ctx.lineWidth = 0.5; polys.forEach((p, idx) => { ctx.strokeStyle = overlapIndices.has(idx) ? '#ff4444' : '#4ade80'; ctx.beginPath(); p.pts.forEach((pt, i) => { const px = (pt.x - minX) * scale + 5; const py = (pt.y - minY) * scale + 5; if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py); }); ctx.closePath(); ctx.stroke(); }); }
</script></body></html>
